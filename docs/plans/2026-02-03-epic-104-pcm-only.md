# EPIC-104 PCM-only Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** HTTP API ã‚’ `GET /healthz` + `POST /transcribe_pcm` ã®ã¿ã«ç¸®é€€ã—ã€ffmpeg/ffprobe ä¾å­˜ã¨ä¸è¦çµŒè·¯ï¼ˆCLI/è©±è€…åˆ†é›¢/ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ç­‰ï¼‰ã‚’å®Œå…¨ã«å‰Šé™¤ã™ã‚‹ã€‚

**Architecture:** PCM(s16le, mono) ã®ã¿ã‚’ FastAPI ã§å—ã‘å–ã‚Šã€`decode_pcm_s16le_bytes` â†’ `transcribe_waveform(_chunked)` ã®æœ€çŸ­çµŒè·¯ã¸åæŸã•ã›ã‚‹ã€‚ãƒ•ã‚¡ã‚¤ãƒ«/ã‚¹ãƒˆãƒªãƒ¼ãƒ /è©±è€…åˆ†é›¢/éŒ²éŸ³/ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã®å…¥å£ã¯å‰Šé™¤ã—ã€ä¾å­˜é–¢ä¿‚ã¨ãƒ†ã‚¹ãƒˆã‚’ PCM-only ã«æœ€å°åŒ–ã™ã‚‹ã€‚

**Tech Stack:** Python 3.13, FastAPI, mlx-whisper, numpy, unittest

---

### Task 1: ISSUE-1 API ç¸®é€€ï¼ˆ`/transcribe` å‰Šé™¤ï¼‰

**Files:**
- Modify: `src/cmd/http.py`
- Create: `tests/test_http_transcribe_routes.py`

**Step 1: Write the failing test**
```python
# tests/test_http_transcribe_routes.py
import sys
import types
import unittest
from fastapi.testclient import TestClient

# mlx_whisper stub
original_mlx = sys.modules.get("mlx_whisper")
original_mlx_audio = sys.modules.get("mlx_whisper.audio")
mlx_stub = types.ModuleType("mlx_whisper")
audio_stub = types.ModuleType("mlx_whisper.audio")
audio_stub.SAMPLE_RATE = 16000
mlx_stub.transcribe = lambda *args, **kwargs: None
mlx_stub.audio = audio_stub
sys.modules["mlx_whisper.audio"] = audio_stub
sys.modules["mlx_whisper"] = mlx_stub


def _restore():
    if original_mlx is not None:
        sys.modules["mlx_whisper"] = original_mlx
    else:
        sys.modules.pop("mlx_whisper", None)
    if original_mlx_audio is not None:
        sys.modules["mlx_whisper.audio"] = original_mlx_audio
    else:
        sys.modules.pop("mlx_whisper.audio", None)


class TestHttpRoutes(unittest.TestCase):
    @classmethod
    def tearDownClass(cls) -> None:
        _restore()

    def test_transcribe_is_removed(self) -> None:
        from src.cmd.http import create_app
        client = TestClient(create_app())
        res = client.post("/transcribe")
        self.assertEqual(res.status_code, 404)


if __name__ == "__main__":  # pragma: no cover
    unittest.main()
```

**Step 2: Run test to verify it fails**
Run: `python -m unittest tests.test_http_transcribe_routes -v`
Expected: FAIL (until `/transcribe` is removed or path is missing)

**Step 3: Write minimal implementation**
```python
# src/cmd/http.py (imports + endpoint removal)
# - Remove /transcribe endpoint function entirely
# - Remove unused imports for /transcribe path
# - Keep /healthz and /transcribe_pcm only
```

**Step 4: Run test to verify it passes**
Run: `python -m unittest tests.test_http_transcribe_routes -v`
Expected: PASS

**Step 5: Commit**
```bash
git add src/cmd/http.py tests/test_http_transcribe_routes.py
bash "$HOME/.codex/skills/epic-subissue-runner/scripts/run_issue_gates.sh"
git commit -m "ğŸ”§ /transcribe API ã‚’å‰Šé™¤"
```

---

### Task 2: ISSUE-2 audio/inspection ã®å‰Šé™¤

**Files:**
- Delete: `src/lib/audio/inspection.py`
- Modify: `src/lib/audio/__init__.py`

**Step 1: Write the failing test**
```python
# tests/test_audio_inspection_removed.py
import importlib
import unittest

class TestAudioInspectionRemoved(unittest.TestCase):
    def test_inspection_module_is_gone(self) -> None:
        with self.assertRaises(ModuleNotFoundError):
            importlib.import_module("src.lib.audio.inspection")

if __name__ == "__main__":  # pragma: no cover
    unittest.main()
```

**Step 2: Run test to verify it fails**
Run: `python -m unittest tests.test_audio_inspection_removed -v`
Expected: FAIL (module still exists)

**Step 3: Write minimal implementation**
```python
# src/lib/audio/__init__.py
from .utils import (
    AudioDecodeError,
    decode_pcm_s16le_bytes,
)

__all__ = [
    "AudioDecodeError",
    "decode_pcm_s16le_bytes",
]
```

**Step 4: Run test to verify it passes**
Run: `python -m unittest tests.test_audio_inspection_removed -v`
Expected: PASS

**Step 5: Commit**
```bash
git add src/lib/audio/__init__.py tests/test_audio_inspection_removed.py
rm src/lib/audio/inspection.py
bash "$HOME/.codex/skills/epic-subissue-runner/scripts/run_issue_gates.sh"
git commit -m "ğŸ”§ audio inspection ã‚’å‰Šé™¤"
```

---

### Task 3: ISSUE-3 ffmpeg/ffprobe ä¾å­˜ã®æ ¹çµ¶ï¼ˆutils/pipeline/chunking/service ã»ã‹ï¼‰

**Files:**
- Modify: `src/lib/audio/utils.py`
- Modify: `src/lib/asr/pipeline.py`
- Modify: `src/lib/asr/chunking.py`
- Modify: `src/lib/asr/service.py`
- Modify: `src/lib/asr/main.py`
- Modify: `src/lib/asr/__init__.py`
- Delete: `src/lib/asr/subproc.py`
- Delete: `src/lib/asr/streaming_input.py`
- Delete: `src/lib/asr/streaming_runtime.py`
- Delete: `src/lib/diarize/*` (module å…¨ä½“)

**Step 1: Write the failing test**
```python
# tests/test_ffmpeg_strings.py
import subprocess
import unittest

class TestFfmpegStrings(unittest.TestCase):
    def test_ffmpeg_grep_is_empty(self) -> None:
        result = subprocess.run(
            ["git", "grep", "-nE", r"\\bffmpeg\\b|\\bffprobe\\b"],
            capture_output=True,
            text=True,
        )
        self.assertNotEqual(result.returncode, 0)

if __name__ == "__main__":  # pragma: no cover
    unittest.main()
```

**Step 2: Run test to verify it fails**
Run: `python -m unittest tests.test_ffmpeg_strings -v`
Expected: FAIL (grep hits found)

**Step 3: Write minimal implementation**
```python
# src/lib/audio/utils.py
# - remove decode_audio_bytes, coerce_to_bytes, encode_waveform_to_wav_bytes
# - keep AudioDecodeError, decode_pcm_s16le_bytes, _resample_waveform

# src/lib/asr/pipeline.py
# - remove transcribe_paths / transcribe_streams and related helpers
# - remove _translate_decode_error ffmpeg branches
# - keep transcribe_waveform + silence helpers

# src/lib/asr/chunking.py
# - remove transcribe_paths_chunked and bytes-path branch
# - remove encode_waveform_to_wav_bytes usage
# - keep transcribe_waveform_chunked waveform-only

# src/lib/asr/service.py
# - remove transcribe_prepared_audios
# - keep resolve_model_and_language only

# src/lib/asr/main.py / __init__.py
# - drop transcribe_all / transcribe_all_bytes exports if unused

# delete ffmpeg callers:
# - src/lib/asr/subproc.py
# - src/lib/asr/streaming_input.py
# - src/lib/asr/streaming_runtime.py
# - src/lib/diarize/*
```

**Step 4: Run test to verify it passes**
Run: `python -m unittest tests.test_ffmpeg_strings -v`
Expected: PASS

**Step 5: Commit**
```bash
git add src/lib/audio/utils.py src/lib/asr/pipeline.py src/lib/asr/chunking.py src/lib/asr/service.py \
  src/lib/asr/main.py src/lib/asr/__init__.py tests/test_ffmpeg_strings.py
rm -rf src/lib/asr/subproc.py src/lib/asr/streaming_input.py src/lib/asr/streaming_runtime.py src/lib/diarize
bash "$HOME/.codex/skills/epic-subissue-runner/scripts/run_issue_gates.sh"
git commit -m "ğŸ”§ ffmpeg/ffprobe ä¾å­˜ã‚’å‰Šé™¤"
```

---

### Task 4: ISSUE-4 CLI/Makefile/Docs ã® PCM-only åŒ–

**Files:**
- Delete: `src/cmd/cli.py`
- Modify: `Makefile`
- Modify: `AGENTS.md`
- Delete: `tests/test_cli_*` / `tests/test_asr_stream*` / `tests/test_asr_chunking.py` / `tests/test_asr_subproc.py`

**Step 1: Write the failing test**
```python
# tests/test_cli_removed.py
import importlib
import unittest

class TestCliRemoved(unittest.TestCase):
    def test_cli_module_is_gone(self) -> None:
        with self.assertRaises(ModuleNotFoundError):
            importlib.import_module("src.cmd.cli")

if __name__ == "__main__":  # pragma: no cover
    unittest.main()
```

**Step 2: Run test to verify it fails**
Run: `python -m unittest tests.test_cli_removed -v`
Expected: FAIL

**Step 3: Write minimal implementation**
```makefile
# Makefile
.PHONY: help http test shell
help:
	@echo "Available targets:"
	@echo "  make http                     # FastAPIèµ·å‹•"
	@echo "  make test                     # unit tests"

http:
	uvicorn src.cmd.http:create_app --reload --port 8000 --factory

test:
	python -m unittest discover -s tests
```

```markdown
# AGENTS.md (è©²å½“ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã¿æ›´æ–°)
- PCM-only é‹ç”¨: HTTP ã¯ `POST /transcribe_pcm` ã®ã¿åˆ©ç”¨ã—ã¾ã™ã€‚
- é–‹ç™º: `uvicorn src.cmd.http:create_app --reload --port 8000 --factory`
- ãƒ†ã‚¹ãƒˆ: `python -m unittest discover -s tests`
```

**Step 4: Run test to verify it passes**
Run: `python -m unittest tests.test_cli_removed -v`
Expected: PASS

**Step 5: Commit**
```bash
git add Makefile AGENTS.md tests/test_cli_removed.py
rm -f src/cmd/cli.py
rm -f tests/test_cli_* tests/test_asr_stream* tests/test_asr_chunking.py tests/test_asr_subproc.py
bash "$HOME/.codex/skills/epic-subissue-runner/scripts/run_issue_gates.sh"
git commit -m "ğŸ”§ CLI/Makefile/Docs ã‚’ PCM-only åŒ–"
```

---

### Task 5: ISSUE-5 ãƒ†ã‚¹ãƒˆåˆ·æ–°ï¼ˆ/transcribe_pcm ã®ã¿æ‹…ä¿ï¼‰

**Files:**
- Create: `tests/test_http_transcribe_pcm.py`
- Delete/Trim: `tests/test_audio_*` (ffmpeg/inspection ä¾å­˜ã‚’å‰Šé™¤)

**Step 1: Write the failing test**
```python
# tests/test_http_transcribe_pcm.py
import sys
import types
import unittest
from unittest import mock

import numpy as np
from fastapi.testclient import TestClient

original_mlx = sys.modules.get("mlx_whisper")
original_mlx_audio = sys.modules.get("mlx_whisper.audio")
mlx_stub = types.ModuleType("mlx_whisper")
audio_stub = types.ModuleType("mlx_whisper.audio")
audio_stub.SAMPLE_RATE = 16000
mlx_stub.transcribe = lambda *args, **kwargs: None
mlx_stub.audio = audio_stub
sys.modules["mlx_whisper.audio"] = audio_stub
sys.modules["mlx_whisper"] = mlx_stub


def _restore():
    if original_mlx is not None:
        sys.modules["mlx_whisper"] = original_mlx
    else:
        sys.modules.pop("mlx_whisper", None)
    if original_mlx_audio is not None:
        sys.modules["mlx_whisper.audio"] = original_mlx_audio
    else:
        sys.modules.pop("mlx_whisper.audio", None)


class TestTranscribePCM(unittest.TestCase):
    @classmethod
    def tearDownClass(cls) -> None:
        _restore()

    def _pcm_bytes(self, samples: int = 1600) -> bytes:
        payload = (np.sin(np.linspace(0, np.pi, samples)) * 1000).astype(np.int16)
        return payload.tobytes()

    @mock.patch("src.lib.asr.pipeline.transcribe")
    def test_transcribe_pcm_ok(self, mock_transcribe: mock.Mock) -> None:
        mock_transcribe.return_value = {"text": "ok", "segments": [], "language": "ja", "duration": 0.1}
        from src.cmd.http import create_app
        client = TestClient(create_app())

        res = client.post(
            "/transcribe_pcm",
            files={"file": ("audio.pcm", self._pcm_bytes(), "application/octet-stream")},
            data={"sample_rate": "16000", "model": "fake-model", "language": "ja"},
        )
        self.assertEqual(res.status_code, 200)
        payload = res.json()
        self.assertIsInstance(payload, list)
        self.assertEqual(payload[0]["text"], "ok")

    def test_transcribe_pcm_invalid_length(self) -> None:
        from src.cmd.http import create_app
        client = TestClient(create_app())
        res = client.post(
            "/transcribe_pcm",
            files={"file": ("audio.pcm", b"\\x00", "application/octet-stream")},
            data={"sample_rate": "16000"},
        )
        self.assertEqual(res.status_code, 400)


if __name__ == "__main__":  # pragma: no cover
    unittest.main()
```

**Step 2: Run test to verify it fails**
Run: `python -m unittest tests.test_http_transcribe_pcm -v`
Expected: FAIL (until /transcribe_pcm path is intact and mocks align)

**Step 3: Write minimal implementation**
```python
# If needed, align http endpoint to use transcribe_waveform(_chunked) only.
```

**Step 4: Run test to verify it passes**
Run: `python -m unittest tests.test_http_transcribe_pcm -v`
Expected: PASS

**Step 5: Commit**
```bash
git add tests/test_http_transcribe_pcm.py
bash "$HOME/.codex/skills/epic-subissue-runner/scripts/run_issue_gates.sh"
git commit -m "ğŸ”§ /transcribe_pcm ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ "
```

---

### Task 6: ISSUE-6 ä¾å­˜é–¢ä¿‚ã®æœ€å°åŒ–ï¼ˆpyproject/uv.lockï¼‰

**Files:**
- Modify: `pyproject.toml`
- Modify: `uv.lock`

**Step 1: Write the failing test**
```python
# tests/test_dependencies_minimal.py
import tomllib
import unittest
from pathlib import Path

class TestDependenciesMinimal(unittest.TestCase):
    def test_unwanted_dependencies_removed(self) -> None:
        data = tomllib.loads(Path("pyproject.toml").read_text(encoding="utf-8"))
        deps = data["project"]["dependencies"]
        unwanted = [
            "pyannote-audio",
            "torch",
            "torchaudio",
            "opencv-python-headless",
            "SQLAlchemy",
        ]
        for name in unwanted:
            self.assertTrue(all(not dep.startswith(name) for dep in deps))

if __name__ == "__main__":  # pragma: no cover
    unittest.main()
```

**Step 2: Run test to verify it fails**
Run: `python -m unittest tests.test_dependencies_minimal -v`
Expected: FAIL (unwanted deps still present)

**Step 3: Write minimal implementation**
```toml
# pyproject.toml dependencies: keep only HTTP + PCM-only runtime/test deps
# - fastapi, uvicorn, pydantic, python-multipart
# - mlx, mlx-whisper, numpy
# - httpx, psutil
```

**Step 4: Run test to verify it passes**
Run: `python -m unittest tests.test_dependencies_minimal -v`
Expected: PASS

**Step 5: Commit**
```bash
git add pyproject.toml uv.lock tests/test_dependencies_minimal.py
bash "$HOME/.codex/skills/epic-subissue-runner/scripts/run_issue_gates.sh"
git commit -m "ğŸ”§ ä¾å­˜é–¢ä¿‚ã‚’PCM-onlyæœ€å°ã¸"
```

---

### Final Epic Gates

Run:
- `git grep -nE '\\bffmpeg\\b|\\bffprobe\\b'` (0ä»¶)
- `python -m unittest discover -s tests`
- `uvicorn src.cmd.http:create_app --factory`
