# Issue-2 Streaming Segment Committer Design

## Design
This design introduces a small stateful helper, `SegmentCommitter`, that converts per-window Whisper results into a stable, appended transcript without replaying past text. The core idea is to treat each ASR call as a fixed-length window and compute a commit cutoff at `now_total_seconds - lookback_seconds` (or the full duration for final). Each incoming segment is converted to absolute time by adding `window_start_seconds` to its start/end, then sorted by end time. Segments are committed only if their end time is at or before the cutoff and strictly later than the last committed boundary. To avoid repeated text from overlapping windows, a minimal de-duplication rule checks the last committed segment: if the text matches (after trim) and the new segment starts within a short gap (<= 0.5s), the new segment is skipped while still advancing the committed boundary.

The committer maintains `committed_until`, `committed_segments`, and `committed_text`, returning only newly committed text per update. A helper `build_result()` constructs a `TranscriptionResult` with the accumulated segments and total duration (end of last committed segment). This keeps logic localized so CLI and HTTP code can share the same behavior in later issues. Error handling is simple: missing segment fields default to 0.0 or empty text, and all inputs are cast to float/str to avoid type surprises. Unit tests cover the cutoff behavior, absolute time conversion, de-duplication, and final commit behavior. This yields predictable transcript growth even as windowed ASR reprocesses overlapping audio.
